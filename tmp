/* Author: Gar_onn

*/


function spotonTasks(){
return {
'tasks': {"n":"My Tasklist","id":0,"s":100,"g":55.51028636264,"c":[{"n":"1 coding","g":60,"s":41,"c":[{"g":95,"n":"1.1 PHP","s":30,"id":2,"p":1},{"g":45,"n":"1.2 JS","s":70,"id":3,"p":1}],"id":1,"p":0},{"n":"2 rulling the world","g":"25","s":19,"id":4,"p":0},{"n":"3 Design","s":30,"g":79.8676212088,"c":[{"g":"100","n":"3.1 functional","s":50,"id":6,"p":5},{"g":"58","n":"3.2 haha","s":31.251,"id":7,"p":5},{"g":62.62087999999999,"n":"3.3 sander suckt","s":18.751,"c":[{"g":"34","n":"3.3.1 algem","s":47,"id":9,"p":8},{"g":"88","n":"3.3.2 de rest","s":53.001,"id":10,"p":8}],"id":8,"p":5}],"id":5,"p":0},{"g":"22","n":"4 lorem","s":10,"id":11,"p":0}],"display":{"size":6.283185307179586}},


'data' : {
			'blankTask' : {'n':'New subtask','g':0,'s':0},
			'maxId':0,
			'curTask' : 0,
			'tasksById' : new Array(),
			'changesMade': [],
			'screenD':{
						'sizeMiddle': 50,
						'sizeA':50,
						'maxA':3,
						'sizeB':10,
					},
		
			'screen':{
						'centerX': 200,
						'centerY' : 200,
						'sizeMiddle': 30,
						'canvasX': 400,
						'canvasY': 400,
						'sizeA':50,
						'maxA':3,
						'sizeB':45,
						'offset' : 30
					},
			'colorScheme' : {
					'hover' : 	['#4375B0','#AEC5E0'],
					'normal': 	['#0F4688','#479AEB'],
					'selected':	['#E0CB48','#F6F0CB'],
					}
		},

'mouse':{x:0,y:0,hover:0,lastClicked:0},

/*
 * init (constructor function)
 * 
 * function
 *   bind functions, map Id, ...
 *
 * args:
 *   canvasIdentifier : jQuery selector for the canvas
 *
 */
'init':function(canvasIdentifier){
	this.$canvas = 	$(canvasIdentifier);
	this.ctx = 		this.$canvas[0].getContext('2d');


	//enable resizer
	this.resize();
	$(window).resize({o:this},function(e){e.data.o.resize()});

	this.$canvas
		// handel mousemoves
		.mousemove({o:this},function(e){
			var screen = e.data.o.data.screen;
			e.data.o.mouse.x=e.clientX - e.data.o.ctx.canvas.getBoundingClientRect().left;
			e.data.o.mouse.y=e.clientY - e.data.o.ctx.canvas.getBoundingClientRect().top;
			e.data.o.mouse.r=Math.sqrt(
								Math.pow((screen.centerX-e.pageX),2) 
							  + Math.pow((screen.centerY-e.pageY),2));
							
			})
		//handle clicks
		.click({o:this},function(e){
			e.data.o.mouse.lastClicked = e.data.o.mouse.hover;
			e.data.o.fillSidebar(e.data.o.mouse.lastClicked);
			}); 
		
		//handle updates
		$('#n,#s,#g').change({o:this},function(e){
				e.data.o.updateValue($(this).val(),$(this).attr('id'))
			});
	
		//handel edits
		$('#removeTask').click({o:this},function(e){
				e.data.o.remove()
			});
		$('#addNeighbour').click({o:this},function(e){
				e.data.o.add("neighbour")
			});
		$('#addChild').click({o:this},function(e){
				e.data.o.add("child")
			});

	// set base task to zero
	this.data.tasksById[0] = this.tasks;
	this.inTasksId(this.tasks);
	this.fillSidebar(0);
	this.drawGroup();
	return this;
},

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *                                                                           *
 *                     start of task changing methods                        *
 *                                                                           *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 








/* updateValue (setter)
 *
 * function
 *   set values
 *        > localStorage
 *        > to DB
 *
 * args
 *   value - the new value
 *   id    - the attribute to chaneg
 *               > n (name)
 *               > s (size)
 *               > g (gain/progress)
 *
 */
'updateValue' : function(value,id){
		switch(id){
			case 'n':
				var task = this.data.tasksById[this.data.curTask];
				task.n = value;
			break;
			case 's':
				this.updateS(this.data.curTask,value);
			break;
			case 'g':
				this.updateG(this.data.curTask,value);
			break;
		}	
},

/* Updaters 
 * 
 * change the value of a task and sync the other tasks
 *     > change DB
 *     > change localStorage
 * 
 * args
 *    taskId	-	id of the task
 *    newVal	-	new value
 *
 * */
'updateS': function(taskId,newVal){
	var i,	
		task = this.data.tasksById[taskId],
		group = this.data.tasksById[task.p].c,
		otherTot =0,
		notLocked = [];
	
	// find neighbour tasks to fill the gap
	for(i in group){
		if(group[i].l != 1 && group[i].id != taskId){
			notLocked.push(group[i]);
			otherTot+=group[i].s
		}
	}
			
	if(notLocked.length == 0){
		return; // no neigbours to modify
		//TODO: alert user
	}
	

	// update task
	task.s = newVal*1;
	
	var curTot = newVal*1 + otherTot,
		change = (100 - curTot);

	for(i in notLocked){
		var t = notLocked[i];
		t.s += (t.s / otherTot) * change  ;
		t.s = Math.round(1000 * t.s) /1000;

	}

	// update gain/progress of parrent task since this will be modified
	// do this by (re)updateing the gain to current value, so parrent will 
	// recalculate
	this.updateG(taskId,task.g);
},

'updateG' : function(taskId,newVal){
	var i,	
		task = this.data.tasksById[taskId];	
		task.g = newVal;
		pTask = this.data.tasksById[task.p];

	//recalculate parent if there is a one
	if(typeof pTask != 'undefined'){
		var gain = 0;
		for(i in pTask.c){
			gain += (pTask.c[i].g * (pTask.c[i].s / 100));
		}
		
		this.updateG(task.p,gain);
	}
},

/*end of updaters*/

/* add
 *
 * function
 *   add a new task based on the default task (data.blankTask)
 *
 * args
 *   type	-	"child" or "neighbour"
 *   			where to append new task
 */
'add': function(type){
		var parent = this.data.tasksById[this.data.curTask];		
		
		if(type == 'neighbour'){
			parent = this.data.tasksById[parent.p];		
		}
	
		var blankTask = $.extend(true,{},this.data.blankTask);
		this.data.maxId += 1;
		blankTask.id = this.data.maxId;
		blankTask.p = parent.id;
		blankTask.g = parent.g; 
		this.data.tasksById[blankTask.id] = blankTask;
		if(typeof parent.c == 'undefined' || parent.c.length == 0){
			// subtask of 100%	
			blankTask.s = 100;
			parent.c = [blankTask];		
		}else{
			//extra task, resize
	//		parent.c = 
			parent.c.push(blankTask);
			this.updateS(blankTask.id,50);
		}
		
		this.mouse.lastClicked = blankTask.id;
		this.fillSidebar(blankTask.id);
		this.drawGroup();

	},

/* remove
 *
 * function
 *   - remove the current selected task afterconfirming
 *   - remove task based on its id (no confirmation)
 *
 * args
 * [id]		-	Id of the task that should be deleted
 * 				id none given, current selected task will be removed
 *
 */
'remove' : function(id){
	if(typeof id == 'undefined'){
		var task = this.data.tasksById[this.data.curTask];
		if(confirm("delete? are you shure?\n"+task.n)){
			this.remove(task.id);	
			}
			
	}else{
			
		var task = this.data.tasksById[this.data.curTask];
		var parent = this.data.tasksById[task.p];
		var i;
		for(i in parent.c){
			if(parent.c[i]==task){
				this.updateS(task.id,0);
				parent.c.splice(i,1);
				break;
			}	
		}

	}
},



/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *                                                                           *
 *                      end of task changing methods                         *
 *                                                                           *
 *                     start of HTML edits (sidebar)                         *
 *                                                                           *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */



'fillSidebar': function(taskId){
			this.data.curTask = taskId;
			var task = this.data.tasksById[taskId];
			$('#n').val(task.n);	
			$('#s').val(Math.round(task.s)).attr('value',Math.round(task.s));
			$('#g').val(Math.round(task.g)).attr('value',Math.round(task.g));
			if(typeof task.c == 'undefined' || task.c.length == 0){
				$("#g").removeAttr('disabled');	
				}else{
				$("#g").attr('disabled','disabled');
				}

	},

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *                                                                           *
 *                       end of HTML edits (sidebar)                         *
 *                                                                           *
 *                       start of drawing on canvas                          *
 *                                                                           *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* drawPart
 *
 * function
 *   the method that actualy draws th tasks on the canvas
 *
 *   args
 *     R	-	The maximum radius
 *     prevR-	The radius of the previous circle
 *     startP-	Degree to start drawing
 *     endP	-	Degree to stop drawing
 *     task	-	the task object that will be drawn
 */
'drawPart' : function(R,prevR,startP,endP,task){
	
			var screen = this.data.screen;
			
			this.ctx.beginPath();
			this.ctx.moveTo(screen.centerX,screen.centerY);
			this.ctx.arc(screen.centerX,screen.centerY,R,startP,endP,false);
		
			if(this.mouse.r > prevR && this.ctx.isPointInPath(this.mouse.x,this.mouse.y)  ){
				var fillStyle=  'hover';
				this.mouse.hover = task.id;
				this.mouse.isHovering = true;
			}else{
				var fillStyle = 'normal';
			}
			
			if(this.mouse.lastClicked == task.id){
				var fillStyle += '_selected';
			}
		
			this.ctx.fillStyle = this.generateGradient(prevR,R,task.g,fillStyle,screen);
			this.ctx.closePath();
			this.ctx.fill();	
			this.ctx.stroke();
		},

'generateGradient': function(rMin,rMax,gain,state,screen){
			var radgrad = this.ctx.createRadialGradient(
									screen.centerX,screen.centerY,rMin,
									screen.centerX,screen.centerY,rMax);
				gain = (gain < 100 ? gain:100);
		//		log(arguments,gain,this);
				radgrad.addColorStop(gain/100, this.data.colorScheme[state][0]);
				radgrad.addColorStop(gain/100, this.data.colorScheme[state][1]);
			return radgrad;
		},

'inTasksId': function(data){
		var i;
			for(i in data.c){
				tasks = data.c[i];
				if(this.data.tasksById[tasks.id] == undefined){
					this.data.tasksById[tasks.id] = tasks;
					this.data.maxId=Math.max(this.data.maxId,tasks.id);
				}
				this.inTasksId(tasks)	
			}
		
		},


'drawPt': function(data,startDeg,endDeg,subLvl,screen){
	var curStart = startDeg;
	var curEnd = endDeg
	for(i in data.c){

		var tasks = data.c[i];
		

		var angleSize = (endDeg - startDeg)*(tasks.s / 100);
		curEnd = curStart + angleSize;


		this.drawPt(tasks,curStart,curEnd,subLvl+1,screen);

		if(subLvl-1 >= screen.maxA){
		var prevR =((subLvl-screen.maxA)*screen.sizeB)+(screen.maxA*screen.sizeA);
		}else{
		var prevR = (subLvl) * screen.sizeA;	
		}
		if(subLvl >= screen.maxA){
		var r =prevR+screen.sizeB;
		}else{
		var r = prevR + screen.sizeA;	
		}

		r += screen.sizeMiddle;
		prevR += screen.sizeMiddle;

		this.drawPart(r,prevR,curStart,curEnd,tasks)
		
		var curStart  = curEnd;				

	}

},

'drawGroup' : function(data,startDeg,endDeg,subLvl){
	var i;	
		var screen = this.data.screen;
	

	if(arguments.length<=1 || data=='AF'){
		var data = ((arguments.length == 0 || data=="AF") ? this.tasks : data);
		var startDeg=0;
		var endDeg = this.tasks.display.size;
		var subLvl = 0;
		this.ctx.clearRect(0,0,screen.canvasX,screen.canvasY,1000)

		this.mouse.isHovering = false;
		
	}

	this.drawPt(data,startDeg,endDeg,subLvl,screen)
			
		

	

		if(this.mouse.isHovering == false){
		this.mouse.hover = 0;
		}
		
		var middleStatus = (this.mouse.r < screen.sizeMiddle ? 'hover' : 'normal');
			middleStatus = (this.mouse.lastClicked == 0 ? 'selected' : middleStatus);

this.ctx.fillStyle = this.generateGradient(0,screen.sizeMiddle,data.g,middleStatus,screen);
				
		this.ctx.beginPath();
		this.ctx.arc(screen.centerX,screen.centerY,screen.sizeMiddle,0,this.tasks.display.size)
		this.ctx.closePath();
		this.ctx.fill();
		this.ctx.stroke();
			
	
		
},

'resize':function(){  	// resize canvas if window resized
	this.$canvas//.css("border","1px solid red")
		.attr('width',($(window).width()-260))
		.attr('height',$(window).height()-10);	
	
	var screen = this.data.screen;
	screen.canvasX = this.$canvas.attr('width');
	screen.canvasY = this.$canvas.attr('height');
	screen.centerX = Math.floor(screen.canvasX / 2);
	screen.centerY = Math.floor(screen.canvasY / 2);
	
	var ratio = (Math.min(screen.canvasX,screen.canvasY) / 500); 

	screen.sizeA = this.data.screenD.sizeA * ratio;
	screen.sizeB = this.data.screenD.sizeB * ratio;
	screen.sizeMiddle = this.data.screenD.sizeMiddle * ratio;

		this.ctx.lineStyle = '#032349';
		this.ctx.lineWidth = 3;
		this.ctx.lineCap = 'round';
		this.ctx.lineJoin= 'round';

	this.drawGroup();
},

'AF': function(){
//			log(this,arguments,thing,"hey")
		thing.drawGroup('AF');
		window.requestAnimFrame(thing.AF,thing.ctx.canvas);
		},

'aaa':'aaa'

}

}










window.requestAnimFrame = (function(){
	  return  window.requestAnimationFrame       || 
			window.webkitRequestAnimationFrame || 
			window.mozRequestAnimationFrame    || 
			window.oRequestAnimationFrame      || 
			window.msRequestAnimationFrame     || 
		   function(/* function */ callback, /* DOMElement */ element){
			window.setTimeout(callback, 1000 / 60);
			  };
			  })();







thing = spotonTasks().init('canvas');
thing.AF();

// verry bad things to get the CSS attr(value) working for the rages
$("input[type='range']").change(function(){var a= $(this).val();$(this).attr('value',a);})




